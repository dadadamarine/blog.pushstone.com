---
title: "[Spring/Project] Spring Framework 강의 학습"
author: Push's tone
layout: post
date: 2019-05-30 05:25:28
categories: Java/Spring
---



# 개요

스프링 강의를 다시 보면서 지금까지 학습한 내용들을 복습한다.



# 내용



**의존주입이 언제 일어나나?**

ApplicationContext가 자기안에서 BeanPostProcessor 이라는 빈들을 다 찾는다. 그중 AutowiredAnnotationBeanPostProcessor도 찾아져서, 걔를 다른 일반빈들에 적용시키는것.

-> **beanPostProcessor** 에 의해서(빈 생성 이후, 초기화 라이프사이클 전후에 부가적인 작업을 할 수 있는 라이프 사이클 콜백이 있다. )

그때 초기화전에, AutowiredAnnotationBeanPost--- 실행되서 의존주입 일어남

**DI의 가장큰 장점** 

단위테스트 작성시에 직접 의존객체가 선언되어있을 경우 테스크 작성이 힘듬. 이를 의존주입으로 구현하면, 테스트에서 가짜 객체를 만들어서 주입해줘서 단위 테스트가 가능해짐.



**springboot가 해준것  :** 

1. 모듈간 의존성 관리, 
2. 스프링 설정 ( config등) @Enable AutoConfiguration , 
3. 내장 톰캣(WAS지원), 
4. 실행가능한 WAR파일을 생성 할 수 있게 해줌

스프링 부트는 xml이 아니라, @SpringBootApplication 어노테이션이 @Configuration과  @ComponentScan어노테이션을 가지고 있다. @Configuration을 갖고 있으니 클래스 자체가 configuration 설정 파일이고, @ComponentScan의 역할은 어노테이션이 적용된 DemoApplication이라는 클래스 기준으로 같은레벨. 하위 패키지들을 스캔해서 ApplicationContext안의 빈으로 등록해줌



### 빈의 스코프

#### 빈의 스코프중, 프로토타입 스코프는언제쓸까

짧은 스코프를 가진 빈들을 사용해야할때.

#### 싱글톤 스코프로 사용할 때 주의

싱글톤 클래스의 필드 값이 스레드 안세잎 하다!!

다른곳에서 값을 바꿔서 사용할경우, 바꾼값을 다른 스레드에서 또 바꿔서 이상한 값이 나온다.



#### 빈들은 언제 ioc컨테이너에 등록되나?

기본값 : ApplicationContext를 만들때 생성됨



### Interface ApplicationContext   extends EnviromentAble..?

#### Profile

IOC컨테이너인, ApplicationContext가 구현하는 인터페이스 중 하나는 EnviromentCapable이다. 그리고 이 EnviromentCapable 인터페이스가 **제공하는 기능중 하나는 Profile 기능**이다!!

#### Property

적용되는 레벨이 계층별로 존재함



### Interface ApplicationContext   extends MessageSource











# Spring Data JPA

### Transactional Isolation

1단계 : READ_UNCOMMITED 

- dirty read

  다른곳에서 커밋되지도 않은 트랜잭션에 의해 변한값이 읽히는 현상

2단계 : READ_COMMITTED

- Dirty read 방지
  어떤 사용자가 A라는 데이터를 변경하는 동안, 다른 스레드는 해당 데이터에 접근 할 수 없다.

3단계 : REPEATABLE_READ

- 이 트랜잭션이 실행하는 동안 반복적인 read에 대해 일관성을 제공한다. 다른 트랜잭션에서 이 트랜잭션의 여러번의 read사이에 커밋을 하더라도, 같은 값을 보여주는것을 보장함. (spring data jpa는, 이 3단계를 어플리케이션 레벨에서 보장해줌.)

