---
title: "[Java/Algorithm] 자바 JVM에 대하여"
author: Push's tone
layout: post
date: 2019-05-20 05:25:28
categories: Java
---



# 개요 

각 JVM에 대한 이야기들을 읽으면서 JVM에 대한 개념을 통합/정리/기록 하는 글을 써보고자 한다. 즉 이 글의 내용은 다른 블로그 내용들의 합에 불과합니다. : )

JVM은 JAVA 어플리케이션을 실행하기 위한 run-time 엔진이다. 
자바 코드안에 있는 Main 메서드를 실제로 호출하는 주체가  JVM이다. 

JVM은 JRE의 일부이다. 

<br>

> ### [JRE 란?](<http://www.itworld.co.kr/t/61023/%EA%B0%9C%EB%B0%9C%EC%9E%90/110768#csidx2f38ecaa82880aa8068665c0c4ebc34>)
>
> <br>
>
> 런타임 환경은 다른 소프트웨어를 실행하기 위해 고안되는 일종의 소프트웨어다. 자바용 런타임 환경인 JRE에는 자바 클래스 라이브러리(Java class libraries)와 자바 클래스 로더(Java class loader), 자바 가상 머신(Java Virtual Machine)이 포함된다.
>
> \- 클래스 로더는 올바르게 클래스를 로드해 코어 자바 클래스 라이브러리에 연결하는 역할을 한다.
> \- JVM은 자바 애플리케이션이 디바이스 또는 클라우드 환경에서 실행되는 데 필요한 리소스를 확보하도록 보장하는 역할을 한다.
> \- JRE는 주로 다른 구성 요소의 컨테이너이며 각 구성 요소의 활동을 조율하는 역할을 한다.
>
> <br>
>
> **자바 런타임 환경**
>
> <br>소프트웨어는 시스템 하드웨어 위에 위치하는 일련의 계층으로 볼 수 있다. 각 계층은 그 위의 계층이 사용하거나 필요한 서비스를 제공한다. 자바 런타임 환경은 컴퓨터 운영체제 위에서 실행되면서 자바를 위한 부가적인 서비스를 제공하는 소프트웨어 계층이다.
>
> JRE는 다양한 운영체제의 요철을 매끄럽게 다듬어 자바 프로그램이 거의 모든 운영체제에서 수정 없이 실행될 수 있도록 한다. 또한 운영체제를 기반으로 그 이상의 부가가치 서비스를 제공하기도 한다. 자동 메모리 관리(Automatic memory management)는 프로그래머가 메모리 할당과 재할당을 수동으로 조작할 필요가 없게 해주는 JRE의 가장 중요한 서비스 중 하나다.
>
> 간단히 말해 JRE는 자바 프로그램을 위한 일종의 메타 운영체제다. 추상화의 전형적인 사례로, 기반 운영체제를 자바 애플리케이션 실행을 위한 일관적인 플랫폼으로 추상화한다.
>
> <br>
>
> **JRE와 JVM의 상호작용**
>
> <br>자바 가상 머신은 라이브 자바 프로그램 실행을 담당하는 실행 소프트웨어 시스템이다. JRE는 자바 코드를 받아서 필요한 라이브러리와 결합한 다음 이 코드를 실행할 JVM을 시작하는 온디스크 시스템이다.
>
> JRE에는 자바 프로그램 실행에 필요한 라이브러리와 소프트웨어가 포함된다. 예를 들어 자바 클래스 로더는 자바 런타임 환경의 일부다. 이 중요한 소프트웨어는 컴파일된 자바 코드를 메모리로 로드하고 적절한 자바 클래스 라이브러리에 이 코드를 연결한다.
>
> 앞서 언급한 계층의 시각에서 보면 JVM은 JRE에 의해 생성된다. 패키지 관점에서 보면 그림과 같이 JRE에 JVM이 포함된다.
>
> ![img](http://www.itworld.co.kr/sites/default/files/image/2018/09/jre-100771531-medium.jpg)
> *Credit: Matthew Tyson*
>
> [출처](http://www.itworld.co.kr/t/61023/%EA%B0%9C%EB%B0%9C%EC%9E%90/110768#csidx2f38ecaa82880aa8068665c0c4ebc34)



![img](<https://cdncontribute.geeksforgeeks.org/wp-content/uploads/jvm-3.jpg>)





GraalVM vs JVM5. 

GraalVM이란? 새로운 JIT 컴파일러를 도입한 컴파일러, 이때 새로운 JIT 컴파일러를 Graal, 새 VM을 GraalVM으로 칭한다. 또한 이 JIT 컴파일러만 사용할 수도 있다.



> ### [JIT에 대한 설명](<https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2>)
>
> #### JVM 이란?
>
> Java Virtual Machine 의 줄임말 이며 Java Byte Code를 OS에 맞게 해석 해주는 역할을 합니다. Java compiler는 .java 파일을 .class 라는 Java byte code로 변환 시켜 줍니다. Byte Code 는 기계어가 아니기 때문에OS에서 바로 실행되지 않습니다. 이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다. 하지만 JVM의 해석을 거치기 때문에 c언어 같은 네이티브 언어에비해 속도가 느렸지만 JIT(Just In Time)컴파일러를 구현해 이점을 극복했습니다. **Byte Code는 JVM 위에서 OS상관없이 실행된다**. 이런 점이 Java의 가장 큰 장점이라고 할수 있습니다. OS에 종속적이지 않고 Java 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행 할 수 있습니다. JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine 3가지로 구성되어 있고 자세한 설명은 아래에 이이서 하겠습니다.
>
> ![img](https://cdn-images-1.medium.com/max/1600/1*slIuYO633BCuBh_gfYRmGg.png)
>
> <br>
>
> ### [JVM 구조]((<https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2>))
>
> #### Class Loader
>
> RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.
>
> #### Runtime Data Areas
>
> JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, Runtime Data Areas는 크게 5가지 영역으로 나눌 수 있습니다.
>
> 
>
> ![img](https://cdn-images-1.medium.com/max/1600/1*Zsmrw8DvVSLpRr0mvdNCuA.png)
>
> #### Execution Engine
>
> Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine입니다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Executin Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행합니다.
>
> 최초 JVM 이 나왔을 당시에는 Interperter방식(한 줄씩 해석하고 실행)이였기 때문에 속도가 느리다는 단점이 있었지만 JIT complier 방식을 통해 이 점을 보완했습니다. JIT는 ByteCode를 어셈블러 같은 NativeCode로 바꿔서 실행이 빠르지만 역시 변환하는데 비용이 발생합니다. 이 같은 이유 때문에 JVM은 모든 코드를 JIT Compiler 방식으로 실행하지 않고 Interpreter 방식을 사용하다 일정한 기준이 넘어가면 JIT Compiler 방식으로 실행합니다.



### [Execution Engine]

클래스 로더에 의해 JVM 메모리 공간에 적재된 바이트 코드를 Execution Engine(이하 "실행 엔진")을 이용해 실행합니다. 하지만 바이트 코드를 그대로 쓰는 것은 아니고 기계어로 변경한 뒤에 사용하게 됩니다. 해당 작업을 실행 엔진이 합니다. 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용합니다. 각각 Interpreter와 JIT (Just-In-Time) compiler입니다.

**Interpreter**(이하 "인터프리터")는 우리가 알고 있는대로 방식대로 바이트 코드를 실행합니다. 하나의 명령어를 그때그때 해석해서 실행하게 되어 있습니다. **JIT (Just-In-Time) compiler**(이하 "JIT 컴파일러")는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었습니다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 네이티브 코드로 변경합니다. 이후에는 실행 엔진이 인터프리터 대신 네이티브로 컴파일된 코드를 실행합니다.



다만 JIT 컴파일러와 Java 컴파일러는 다른 것입니다. 다이어그램을 보면 이해가 빠를 것 같습니다.

```
                     Java Compiler             JIT Compiler
                           ↓                         ↓
Java Source Code(.java) ------- Bytecode (.class) ------- Native Code
```





저장!

[Java 가비지 콜렉션 기본 사항](<https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html>)

[JAVA HEap 메모리 모델](<https://lyb1495.tistory.com/3>)

[JVM이란?](<https://asfirstalways.tistory.com/158>)