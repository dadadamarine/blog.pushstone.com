---
title: "[Java/Algorithm] 자바 JVM에 대하여"
author: Push's tone
layout: post
date: 2019-05-20 05:25:28
categories: Java
---



# 개요 

각 JVM에 대한 이야기들을 읽으면서 JVM에 대한 개념을 통합/정리/기록 하는 글을 써보고자 한다. 즉 이 글의 내용은 다른 블로그 내용들의 합에 불과합니다. : )

JVM은 JAVA 어플리케이션을 실행하기 위한 run-time 엔진이다. 
자바 코드안에 있는 Main 메서드를 실제로 호출하는 주체가  JVM이다. 

JVM은 JRE의 일부이다. 

<br>

> ### [JRE 란?](<http://www.itworld.co.kr/t/61023/%EA%B0%9C%EB%B0%9C%EC%9E%90/110768#csidx2f38ecaa82880aa8068665c0c4ebc34>)
>
> <br>
>
> 런타임 환경은 다른 소프트웨어를 실행하기 위해 고안되는 일종의 소프트웨어다. 자바용 런타임 환경인 JRE에는 자바 클래스 라이브러리(Java class libraries)와 자바 클래스 로더(Java class loader), 자바 가상 머신(Java Virtual Machine)이 포함된다.
>
> \- 클래스 로더는 올바르게 클래스를 로드해 코어 자바 클래스 라이브러리에 연결하는 역할을 한다.
> \- JVM은 자바 애플리케이션이 디바이스 또는 클라우드 환경에서 실행되는 데 필요한 리소스를 확보하도록 보장하는 역할을 한다.
> \- JRE는 주로 다른 구성 요소의 컨테이너이며 각 구성 요소의 활동을 조율하는 역할을 한다.
>
> <br>
>
> **자바 런타임 환경**
>
> <br>소프트웨어는 시스템 하드웨어 위에 위치하는 일련의 계층으로 볼 수 있다. 각 계층은 그 위의 계층이 사용하거나 필요한 서비스를 제공한다. 자바 런타임 환경은 컴퓨터 운영체제 위에서 실행되면서 자바를 위한 부가적인 서비스를 제공하는 소프트웨어 계층이다.
>
> JRE는 다양한 운영체제의 요철을 매끄럽게 다듬어 자바 프로그램이 거의 모든 운영체제에서 수정 없이 실행될 수 있도록 한다. 또한 운영체제를 기반으로 그 이상의 부가가치 서비스를 제공하기도 한다. 자동 메모리 관리(Automatic memory management)는 프로그래머가 메모리 할당과 재할당을 수동으로 조작할 필요가 없게 해주는 JRE의 가장 중요한 서비스 중 하나다.
>
> 간단히 말해 JRE는 자바 프로그램을 위한 일종의 메타 운영체제다. 추상화의 전형적인 사례로, 기반 운영체제를 자바 애플리케이션 실행을 위한 일관적인 플랫폼으로 추상화한다.
>
> <br>
>
> **JRE와 JVM의 상호작용**
>
> <br>자바 가상 머신은 라이브 자바 프로그램 실행을 담당하는 실행 소프트웨어 시스템이다. JRE는 자바 코드를 받아서 필요한 라이브러리와 결합한 다음 이 코드를 실행할 JVM을 시작하는 온디스크 시스템이다.
>
> JRE에는 자바 프로그램 실행에 필요한 라이브러리와 소프트웨어가 포함된다. 예를 들어 자바 클래스 로더는 자바 런타임 환경의 일부다. 이 중요한 소프트웨어는 컴파일된 자바 코드를 메모리로 로드하고 적절한 자바 클래스 라이브러리에 이 코드를 연결한다.
>
> 앞서 언급한 계층의 시각에서 보면 JVM은 JRE에 의해 생성된다. 패키지 관점에서 보면 그림과 같이 JRE에 JVM이 포함된다.
>
> ![img](http://www.itworld.co.kr/sites/default/files/image/2018/09/jre-100771531-medium.jpg)
> *Credit: Matthew Tyson*
>
> [출처](http://www.itworld.co.kr/t/61023/%EA%B0%9C%EB%B0%9C%EC%9E%90/110768#csidx2f38ecaa82880aa8068665c0c4ebc34)




#기본

## [자바프로그램 실행과정](<https://asfirstalways.tistory.com/158>)

<Br>

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. 
   JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러(javac)가 자바소스(.java)코드를 읽어 들여 자바 바이트코드(.class)로 변환시킨다.
3. 이 변경된 Class 파일들을 Class Loader를 통해 JVM 메모리영역(Runtime Data Areas) 영역으로 로딩한다.
4. 로딩된 class파일들은 Execution engine을 통해 해석된다.
5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게된다.
   이러한 실행과정속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.

<br>

아래는 JVM 실행과정을 그림으로 표현한것이다.

<br>

![img](https://t1.daumcdn.net/cfile/tistory/25616D45576B854C3F)

그림2

<br>



#### Class Loader

JVM은 컴파일 타임이 아닌 런타임시에 처음으로 클래스를 참조할때 해당 클래스를 로드하고 RuntimeDataArea에 배치한다. 이 동적 로드를 담당하는 부분이 JVM의 Class Loader이다.

JVM내로 클래스(.class파일)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. Runtime 시에 동적으로 클래스를 로드한다. jar파일 내 저장된 클래스들을 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다. (컴파일러 역할) 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조한다.즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것이다. 그 역할을 클래스 로더가 수행한다.



> ### [JIT에 대한 설명](<https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2>)
>
> #### JVM 이란?
>
> Java Virtual Machine 의 줄임말 이며 Java Byte Code를 OS에 맞게 해석 해주는 역할을 합니다. Java compiler는 .java 파일을 .class 라는 Java byte code로 변환 시켜 줍니다. Byte Code 는 기계어가 아니기 때문에OS에서 바로 실행되지 않습니다. 이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다. 하지만 JVM의 해석을 거치기 때문에 c언어 같은 네이티브 언어에비해 속도가 느렸지만 JIT(Just In Time)컴파일러를 구현해 이점을 극복했습니다. **Byte Code는 JVM 위에서 OS상관없이 실행된다**. 이런 점이 Java의 가장 큰 장점이라고 할수 있습니다. OS에 종속적이지 않고 Java 파일 하나만 만들면 어느 디바이스든 JVM 위에서 실행 할 수 있습니다. JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine 3가지로 구성되어 있고 자세한 설명은 아래에 이이서 하겠습니다.
>
> ![img](https://cdn-images-1.medium.com/max/1600/1*slIuYO633BCuBh_gfYRmGg.png)
>
> <br>
>
> ### [JVM 구조]((<https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2>))
>
> #### Class Loader
>
> RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.
>
> #### Runtime Data Areas
>
> JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, Runtime Data Areas는 크게 5가지 영역으로 나눌 수 있습니다.
>
> 
>
> ![img](https://cdn-images-1.medium.com/max/1600/1*Zsmrw8DvVSLpRr0mvdNCuA.png)
>
> #### Execution Engine
>
> Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine입니다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Executin Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행합니다.
>
> 최초 JVM 이 나왔을 당시에는 Interperter방식(한 줄씩 해석하고 실행)이였기 때문에 속도가 느리다는 단점이 있었지만 JIT complier 방식을 통해 이 점을 보완했습니다. JIT는 ByteCode를 어셈블러 같은 NativeCode로 바꿔서 실행이 빠르지만 역시 변환하는데 비용이 발생합니다. 이 같은 이유 때문에 JVM은 모든 코드를 JIT Compiler 방식으로 실행하지 않고 Interpreter 방식을 사용하다 일정한 기준이 넘어가면 JIT Compiler 방식으로 실행합니다.



### [Execution Engine]

클래스 로더에 의해 JVM 런타임 데이터 영역에 배치된 바이트 코드를 Execution Engine(이하 "실행 엔진")을 이용해 실행합니다. 하지만 바이트 코드를 그대로 쓰는 것은 아니고 기계어로 변경한 뒤에 사용하게 됩니다. 해당 작업을 실행 엔진이 합니다. 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용합니다. 각각 Interpreter와 JIT (Just-In-Time) compiler입니다.

**Interpreter**(이하 "인터프리터")는 우리가 알고 있는대로 방식대로 바이트 코드를 실행합니다. 하나의 명령어를 그때그때 해석해서 실행하게 되어 있습니다. 이는 인터프리터 언어의 단점인, 한줄 씩 수행하기 때문에 느리다는 단점을 갖고 있다.

**JIT (Just-In-Time) compiler**(이하 "JIT 컴파일러")는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었습니다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 네이티브 코드로 변경합니다. 이 네이티브 코드는 캐시에 보관하여, 이후에는 실행 엔진이 인터프리터 대신 네이티브로 컴파일된 코드를 실행합니다. 또한 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을때만 컴파일을 수행한다.



다만 JIT 컴파일러와 Java 컴파일러는 다른 것입니다. 다이어그램을 보면 이해가 빠를 것 같습니다.

```
                     Java Compiler             JIT Compiler
                           ↓                         ↓
Java Source Code(.java) ------- Bytecode (.class) ------- Native Code
```



GraalVM vs JVM5. 

GraalVM이란? 새로운 JIT 컴파일러를 도입한 컴파일러, 이때 새로운 JIT 컴파일러를 Graal, 새 VM을 GraalVM으로 칭한다. 또한 이 JIT 컴파일러만 선택적으로 사용할 수도 있다.









### [Runtime Data Areas](<https://asfirstalways.tistory.com/158>)

런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 5개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용한다.

![img](https://i.imgur.com/zv717Hf.png)

그림 3

<br>

아래그림은 실제 런타임시에 어떻게 클래스들과 객체 그리고 지역변수들이 할당되는지에 대한 것을 그림으로 표현한것이다.

![img](https://i.imgur.com/pAh5gIZ.png)

그림 4

<br>

##### PC Register

각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성되는 공간이다. Thread가 어떤 부분을 어떤 명령으로 실행되어야 할지에 대한 기록을 하는 부분으로, 현재 수행중인 JVM명령의 주소를 갖는다.

##### Stack Area

이곳에는 지역변수, 매개변수, 메소드 정보, 연산중 발생하는 임시 데이터등 저장이 된다.JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.

> Stack에 저장되는 Element의 단위는 frame 이라한다.

##### Native method stack area

자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간이다.
JNI(Java Native Interface)를 통해 호출하는 C/C++등의 코드를 수행하기위한 스택 공간이다.

##### Heap Area

Runtime 에 동적으로 할당되는 데이터가 저장되는 영역입니다. 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간이다. Heap에 할당된 데이터는 GC의 대상입니다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.

##### Method Area(Class Area, Code Area, Static Area)

1. 메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. 

2. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관한다.

3. 클래스 정보를 처음 메모리공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간.

4. 올라가게되는 메소드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드이다.  자바 프로그램은 main메소드의 호출에서부터 계속된 메소드의 호출로 흐름을 이어가기 때문이다. 대부분 인스턴스의 생성도 메소드 내에서 실행하고 호출한다. 사실상 컴파일 된 바이트코드의 대부분이 메소드 바이트 코드이기 때문에, 거의 모든 바이트 코드가 올라간다고 봐도 상관없다.

5. ######Runtime constant pool
   Runtime constant pool 은 Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조하여 중복을 막는 역할을 한다.
   1. 올라가는 정보의 종류
      1) Field Information : 멤버변수의 이름, 데이터 타입, 접근 제어자에 대한 정보
      2) Method Information : 메소드의 이름, 리턴 타입, 매개변수, 접근제어자에 대한 정보
      3) Type Information : class인지 interfacea인지 여부를 저장, Type의 속성, 전체 이름, super class의 전체이름(interface 이거나 object인 경우 제외)



##### Heap( 힙 영역 )

Method Area는 클래스 데이터를 위한 공간이라면 Heap영역이 객체를 위한 공간이다. Method Area와 마찬가지로 GC의 관리대상에 포함된다.

객체를 저장하는 가상 메모리 공간이다. new 연산자로 생성된 객체와 배열을 저장한다. 물론 class area영억에 올라온 클래스들만 객체로 생성 할 수 있다. 힙은 세 부분으로 나눌 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/266E283B576B8E060B)

##### Permanent Generation

생성된 객체들에 대한 정보의 주소값이 저장된 공간이다.  Class loader에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용된다. 

Reflection을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 내부적으로 Reflection 기능을 자주 사용하는 Spring Framework를 이용할 경우 이 영역에 대한 고려가 필요하다.



##### New/Young 영역

- Eden : 객체들이 최초로 생성되는 공간
- Survivor 0 / 1 : Eden에서 참조되는 객체들이 저장되는 공간



##### Old 영역

New area에서 일정 시간 참조되고 있는, 살아남은 객체들이 점점 많아진다. Eden에 객체가 가득 차게되면 첫번째 GC(minor GC)가 발생한다. Eden영역에 있는 값들을 Survivor 1 영역에 복사하고 이 영역을 제외한 나머지 영역의 객체를 삭제한다.

인스턴스는 소멸 방법과 소멸 시점이 지역 변수와는 다르기 때문에 힙이라는 별도의 영역에 할당된다. 자바 가상 머신은 매우 합리적으로 인스턴스를 소멸시킨다. 더이상 인스턴스의 존재 이유가 없을때 소멸시킨다.





## 가비지 컬렉션(GC)

### GC 기본

![img](https://t1.daumcdn.net/cfile/tistory/266E283B576B8E060B)

> 힙영역 네이밍이 소름돋는다. 하나의 스토리를 보는 것 같다.

<br>

#### Minor GC

새로 생성된 대부분의 객체(Instance)는 Eden 영역에 위치한다. Eden영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor영역중 하나로 이동된다. 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 일정시간 참조되고 있다는 뜻이므로 Old영역으로 이동시킨다.



# 추가

###[자바의 특징](https://hoonmaro.tistory.com/9)

 **동적 로딩(Dynamic Loading)을 지원한다.**

- 자바 애플리케이션은 클래스로부터 생성 된 여러 개의 객체가 서로 연결되어 실행된다.
- 애플리케이션 실행 시 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적 로딩해서 객체를 생성한다.
- 또, 개발 완료 후 수정 사항이 발생하더라도 해당 클래스만 수정 하면 되므로 전체 애플리케이션을 다시 컴파일 할 필요가 없다. 따라서 유지보수를 쉽고 빠르게 진행 수 있다.





###AOT(Ahead-of-Time) Compiler vs JIT (Just-In-Time) Compiler VS Interpreter

전통적인 입장에서 컴퓨터 프로그램을 만드는 방법은 두가지가 있는데, 인터프리트 방식과 정적 [컴파일](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC) 방식으로 나눌 수 있다. 이 중 인터프리트 방식은 실행 중 프로그래밍 언어를 읽어가면서 해당 기능에 대응하는 기계어 코드를 실행하며, 반면 정적 컴파일은 실행하기 전에 프로그램 코드를 기계어로 번역한다.

 

AOT : Static(정적) 컴파일러, 실행시점 앞에서 중간언어(by JAVAC 컴파일러)를 기계어로 미리 번역하는 방식, + 중간 언어로 배포된 바이트 코드를 미리 목표 시스템에 맞게 기계어로 변역하는 방식.

Interpreter : 고급 언어로 작성된 원시코드 명령어들을 한번에 한줄씩 읽어들여서 실행하는 프로그램. 고급 명령어를 중간 형태로 번역한후, 그것을 실행한다.

JIT 컴파일 : 동적 번역이라고도 불림. 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법. 위 두가지 방식을 혼합한 방식이다. 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성한 뒤, 그 기계어 코드를 캐싱하여 같은 함수가 여러번 불릴 때마다 매번 기계어 코드를 생성하는 것을 방지한다(이후에는 캐싱된 코드를 가져다 쓴다.). JVM은 실행 중에 수집 된 프로파일 링 정보를 기반으로 JIT로 컴파일 할 코드를 결정합니다.

보통 인터프리터 방식의 언어들이 성능향상의 목적으로 JIT컴파일러를 도입한다. 

미리 컴파일된 코드를 실행하지 않고, 런타임에 동적으로 코드를 생성하여 실행한다는 특징 때문에 잠재적인 보안문제가 있음.



<https://www.baeldung.com/ahead-of-time-compilation>

JVM은 JIT의 방식으로, 최적화된 성능과,  peak 성능을 향상시킬 수 있다. 하지만 실행코드가 아직 JIT 컴파일 되지 않았기 때문에 start up 시간은 아직 최적이지 못하다. AOT는 이 warming-up 시간을 향상시키는데 목적이 있다. AOT를 위해 사용되는 컴파일러가 Graal이다.





[GraalVM발표](<http://taewan.kim/post/graalvm_seminar/>), [JIT 나무위키](<https://namu.wiki/w/JIT>), [AOT 위키](<https://ko.wikipedia.org/wiki/AOT_%EC%BB%B4%ED%8C%8C%EC%9D%BC>), [JIT 위키](<https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC>)











저장!

[Java 가비지 콜렉션 기본 사항](<https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html>)

[JAVA HEap 메모리 모델](<https://lyb1495.tistory.com/3>)

[JVM이란?](<https://asfirstalways.tistory.com/158>)

<https://www.geeksforgeeks.org/jvm-works-jvm-architecture/>